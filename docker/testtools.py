#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at

#        http://www.apache.org/licenses/LICENSE-2.0

#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.


from unittest import TestCase

from random import getrandbits, randrange
from hashlib import sha256

from zope.interface import implementer
from zope.interface.verify import verifyObject

from docker.client import IDockerClient
from docker.errors import APIError


def random_container_id():
    """
    Generate a random ID similar to a container ID generated by Docker.

    > The container ID is a 64 Hex digit long random number

    https://books.google.es/books?isbn=178439193X

    :returns: A random 64 character hexidecimal string.
    """
    return sha256(bytes(getrandbits(64))).hexdigest()


def random_name():
    """
    :returns: A short, random name.
    """
    return bytes(randrange(10 ** 6))


def random_name_for_test(test_case):
    """
    Return a short, random name.

    :param TestCase test_case: The test case being run.  The test method that
        is running will be mixed into the name.

    :return name: A random ``unicode`` name.
    """
    return u"{}-{}".format(
        test_case.id().replace(u".", u"_"),
        random_name()
    )


@implementer(IDockerClient)
class FakeDockerClient(object):
    """
    An in-memory implementation of ``IDockerClient``.
    """
    def __init__(self):
        self._containers = {}

    def _get_container(self, container):
        for container_id, container_details in self._containers.items():
            if container in (container_id, container_details['Name']):
                return container_details
        else:
            raise KeyError(container)

    def containers(self, quiet=False, all=False):
        return [
            {'Id': container['Id']}
            for container in self._containers.values()
        ]

    def inspect_container(self, container):
        try:
            container_details = self._get_container(container)
        except KeyError:
            raise APIError(
                message='',
                response=FakeResponse(
                    status_code=404,
                    content={"message": "foo"},
                )
            )
        return container_details

    def create_container(self, image, name=None):
        if name is None:
            name = random_name()
        container_id = random_container_id()
        container = {
            u'Id': container_id,
            # See https://github.com/docker/docker/issues/6705
            u'Name': u'/' + name,
        }
        self._containers[container_id] = container
        container_response = container.copy()
        container_response['warnings'] = None
        return container

    def remove_container(self, container):
        try:
            container_details = self._get_container(container)
            self._containers.pop(container_details['Id'])
        except KeyError:
            raise APIError(
                message='',
                response=FakeResponse(
                    status_code=404,
                    content={"message": "foo"},
                )
            )


class FakeResponse(object):
    """
    XXX Find an existing FakeResponse or a ``requests.Response`` factory.
    """
    content = b'FAKE CONTENT'
    reason = b'FAKE REASON'

    def __init__(self, status_code, content=None):
        self.status_code = status_code
        if content is not None:
            self.content = content

    def json(self):
        return self.content


def try_remove_container(client, container):
    try:
        client.remove_container(container=container)
    except APIError:
        pass


def container_for_test(test_case, **create_container_kwargs):
    """
    Call ``create_container`` on the ``IDockerClient`` implementation for the
    supplied test and register a cleanup callback to remove the container when
    the test completes.
    """
    if 'image' not in create_container_kwargs:
        create_container_kwargs['image'] = 'busybox:latest'
    if 'name' not in create_container_kwargs:
        create_container_kwargs['name'] = random_name_for_test(
            test_case=test_case
        )
    container_id = test_case.client.create_container(
        **create_container_kwargs
    )['Id']
    test_case.addCleanup(
        try_remove_container,
        client=test_case.client,
        container=container_id
    )
    return container_id


class IDockerClientTestsMixin(object):
    """
    Tests for ``IDockerClient``.
    """
    def test_interface(self):
        """
        The implementation provides ``IDockerClient``.
        """
        self.assertTrue(verifyObject(IDockerClient, self.client))

    def test_created_is_listed(self):
        """
        ``IDockerContainers.create_container`` creates a container
        that can be listed.
        """
        container_id = container_for_test(test_case=self)

        self.assertIn(
            {'Id': container_id},
            self.client.containers(all=True, quiet=True)
        )

    def test_inspect_unknown_container(self):
        """
        ``IDockerContainers.inspect_container`` raises ``XXX`` if supplied with
        a container_id that does not exist.
        """
        container_id = random_container_id()
        with self.assertRaises(APIError) as context:
            self.client.inspect_container(container=container_id)
        self.assertEqual(404, context.exception.response.status_code)

    def test_inspect_container(self):
        """
        ``IDockerContainers.inspect_container`` returns a dictionary of
        container data.
        """
        container_name = random_name_for_test(test_case=self)
        container_id = container_for_test(
            test_case=self,
            name=container_name
        )
        result = self.client.inspect_container(container=container_id)

        self.assertEqual(
            (container_id, container_name),
            # Docker prefixes the name with /
            # https://github.com/docker/docker/issues/6705
            (result['Id'], result['Name'][1:])
        )

    def test_remove_unknown_container(self):
        """
        ``IDockerContainers.remove_container`` raises ``APIError`` if supplied
        with a container_id that does not exist.
        """
        with self.assertRaises(APIError) as context:
            self.client.remove_container(
                container=random_container_id()
            )

        self.assertEqual(404, context.exception.response.status_code)

    def test_remove_container(self):
        """
        ``IDockerContainers.remove_container`` removes only the specified
        container.
        """
        container_id_1 = container_for_test(test_case=self)
        container_id_2 = container_for_test(test_case=self)
        self.client.remove_container(container=container_id_1)
        container_ids = [
            container['Id']
            for container
            in self.client.containers(all=True, quiet=True)
        ]
        container_1_exists = container_id_1 in container_ids
        container_2_exists = container_id_2 in container_ids
        self.assertEqual(
            (container_1_exists, container_2_exists),
            (False, True),
        )


def make_idockerclient_tests(dockerclient_factory):
    """
    Return a ``TestCase`` with tests for verifying that
    ``docker_client_factory`` adheres to ``IDockerClient``.
    """
    class Tests(IDockerClientTestsMixin, TestCase):
        def setUp(self):
            self.client = dockerclient_factory()

    return Tests
